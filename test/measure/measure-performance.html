<html>
    <head>
        <title>Measure performance of library</title>
    </head>

    <body>
    </body>

    <script>
        let start = null
        let text = 'Results\n\n'
        function round(x) { return Math.round(x * 10) / 10 }
        function log(...args) { text += args.join(' ') + '\n'; document.body.innerText = text }
        const count = 100
    </script>

    <script>
        start = new Date()
    </script>
    <script src="node_modules/nimble/dist/nimble.browser.min.js"></script>
    <script>
        log('nimble')

        log('- load (ms):', new Date() - start)

        start = new Date()
        let pubkeys = []
        for (let i = 0; i < count; i++) {
            const privateKey = nimble.PrivateKey.fromRandom()
            pubkeys.push(privateKey.toPublicKey())
        }
        log('- generate keypair (ms):', round((new Date() - start) / count))

        start = new Date()
        for (let i = 0; i < count; i++) {
            pubkeys[i].toAddress()
        }
        log('- calculate address (ms):', round((new Date() - start) / count))

        start = new Date()
        for (let i = 0; i < count; i++) {
            nimble.functions.sha256(new Uint8Array(1024).fill(i % 256))
        }
        log('- sha256 (ms):', round((new Date() - start) / count))

        const txid = '0123456701234567012345670123456701234567012345670123456701234567'
        let tx = { inputs: [{ txid, vout: 3 }] }
        let privateKey = nimble.functions.generatePrivateKey()
        let publicKey = nimble.functions.calculatePublicKey(privateKey)
        start = new Date()
        for (let i = 0; i < count; i++) {
            nimble.functions.generateTxSignature(tx, 0, [], 1, privateKey, publicKey)
        }
        log('- sign tx (ms):', round((new Date() - start) / count))

        const signature = nimble.functions.generateTxSignature(tx, 0, [], 1, privateKey, publicKey)
        start = new Date()
        for (let i = 0; i < count; i++) {
            nimble.functions.verifyTxSignature(tx, 0, signature, publicKey, [], 1)
        }
        log('- verify sig (ms):', round((new Date() - start) / count))

        log('')
    </script>

    <script>
        start = new Date()
    </script>
    <script src="node_modules/bsv1/bsv.min.js"></script>
    <script>
        log('bsv1')

        log('- load (ms):', new Date() - start)

        start = new Date()
        pubkeys = []
        for (let i = 0; i < count; i++) {
            const privateKey = new bsv.PrivateKey()
            pubkeys.push(privateKey.toPublicKey())
        }
        log('- generate keypair (ms):', round((new Date() - start) / count))

        start = new Date()
        for (let i = 0; i < count; i++) {
            pubkeys[i].toAddress()
        }
        log('- calculate address (ms):', round((new Date() - start) / count))

        start = new Date()
        for (let i = 0; i < count; i++) {
            bsv.crypto.Hash.sha256(bsv.deps.Buffer.from(new Uint8Array(1024).fill(i % 256)))
        }
        log('- sha256 (ms):', round((new Date() - start) / count))

        privateKey = new bsv.PrivateKey()
        const script = bsv.Script.fromAddress(privateKey.toAddress())
        tx = new bsv.Transaction().from({ txid, vout: 0, script, satoshis: 1 })
        start = new Date()
        for (let i = 0; i < count; i++) {
            tx.inputs[0].script = new bsv.Script()
            tx.sign(privateKey)
        }
        log('- sign tx (ms):', round((new Date() - start) / count))

        start = new Date()
        sig = tx.getSignatures(privateKey)[0].signature
        for (let i = 0; i < count; i++) {
            tx.verifySignature(sig, privateKey.toPublicKey(), 0, script, bsv.crypto.BN.One)
        }
        log('- verify sig (ms):', round((new Date() - start) / count))

        log('')
    </script>

    <script>
        start = new Date()
    </script>
    <script src="node_modules/bsv2/dist/bsv.bundle.js"></script>
    <script>
        log('bsv2')

        log('- load (ms):', new Date() - start)

        start = new Date()
        pubkeys = []
        for (let i = 0; i < count; i++) {
            const privateKey = bsvjs.PrivKey.fromRandom()
            pubkeys.push(bsvjs.PubKey.fromPrivKey(privateKey))
        }
        log('- generate keypair (ms):', round((new Date() - start) / count))

        start = new Date()
        for (let i = 0; i < count; i++) {
            bsvjs.Address.fromPubKey(pubkeys[i])
        }
        log('- calculate address (ms):', round((new Date() - start) / count))

        start = new Date()
        for (let i = 0; i < count; i++) {
            bsvjs.Hash.sha256(bsv.deps.Buffer.from(new Uint8Array(1024).fill(i % 256)))
        }
        log('- sha256 (ms):', round((new Date() - start) / count))

        const txIn = new bsvjs.TxIn().fromBuffer(
            bsvjs.deps.Buffer.from('00000000000000000000000000000000000000000000000000000000000000000000000001ae00000000', 'hex'))
        const txOut = new bsvjs.TxOut().fromBuffer(bsvjs.deps.Buffer.from('050000000000000001ae', 'hex'))
        tx = new bsvjs.Tx().fromObject({
            versionBytesNum: 0,
            txInsVi: bsvjs.VarInt.fromNumber(1),
            txIns: [txIn],
            txOutsVi: bsvjs.VarInt.fromNumber(1),
            txOuts: [txOut],
            nLockTime: 0
        })
        const keyPair = new bsvjs.KeyPair().fromRandom()
        start = new Date()
        for (let i = 0; i < count; i++) {
            tx.sign(keyPair, bsvjs.Sig.SIGHASH_ALL, 0, new bsvjs.Script())
        }
        log('- sign tx (ms):', round((new Date() - start) / count))

        const sig = tx.sign(keyPair, bsvjs.Sig.SIGHASH_ALL, 0, new bsvjs.Script())
        start = new Date()
        for (let i = 0; i < count; i++) {
            tx.verify(sig, keyPair.pubKey, 0, new bsvjs.Script())
        }
        log('- verify sig (ms):', round((new Date() - start) / count))

        log('')
    </script>

    <script type = "module">
        start = new Date()

        log('bsv-wasm')

        import init, { PrivateKey, PublicKey, Hash, Script, SigHash, Transaction } from './node_modules/bsv-wasm/bsv_wasm.js'

        await init()

        log('- load (ms):', new Date() - start)

        start = new Date()
        pubkeys = []
        for (let i = 0; i < count; i++) {
            const privateKey = PrivateKey.fromRandom()
            pubkeys.push(PublicKey.fromPrivateKey(privateKey))
        }
        log('- generate keypair (ms):', round((new Date() - start) / count))

        start = new Date()
        for (let i = 0; i < count; i++) {
            pubkeys[i].toAddress()
        }
        log('- calculate address (ms):', round((new Date() - start) / count))

        start = new Date()
        for (let i = 0; i < count; i++) {
            Hash.sha256(new Uint8Array(1024).fill(i % 256))
        }
        log('- sha256 (ms):', round((new Date() - start) / count))

        const wasm_private_key = PrivateKey.fromWIF("L31JUXCGspUREe9Gya8F2WWjeoRz3bb8AQzJjAP8ntGYp37oYdSx");
        const wasm_public_key = PublicKey.fromPrivateKey(wasm_private_key)
        const wasm_script = Script.fromASMString("OP_0 OP_RETURN");
        const wasm_tx = Transaction.fromHex("01000000029e8d016a7b0dc49a325922d05da1f916d1e4d4f0cb840c9727f3d22ce8d1363f000000008c493046022100e9318720bee5425378b4763b0427158b1051eec8b08442ce3fbfbf7b30202a44022100d4172239ebd701dae2fbaaccd9f038e7ca166707333427e3fb2a2865b19a7f27014104510c67f46d2cbb29476d1f0b794be4cb549ea59ab9cc1e731969a7bf5be95f7ad5e7f904e5ccf50a9dc1714df00fbeb794aa27aaff33260c1032d931a75c56f2ffffffffa3195e7a1ab665473ff717814f6881485dc8759bebe97e31c301ffe7933a656f020000008b48304502201c282f35f3e02a1f32d2089265ad4b561f07ea3c288169dedcf2f785e6065efa022100e8db18aadacb382eed13ee04708f00ba0a9c40e3b21cf91da8859d0f7d99e0c50141042b409e1ebbb43875be5edde9c452c82c01e3903d38fa4fd89f3887a52cb8aea9dc8aec7e2c9d5b3609c03eb16259a2537135a1bf0f9c5fbbcbdbaf83ba402442ffffffff02206b1000000000001976a91420bb5c3bfaef0231dc05190e7f1c8e22e098991e88acf0ca0100000000001976a9149e3e2d23973a04ec1b02be97c30ab9f2f27c3b2c88ac00000000");
        start = new Date()
        for (let i = 0; i < count; i++) {
            let wasm_sighash = wasm_tx.sighashPreimage(SigHash.InputsOutputs, 0, wasm_script, BigInt(0));
            let wasm_sig = wasm_tx.sign(wasm_private_key, SigHash.InputsOutputs, 0, wasm_script, BigInt(0));
        }
        log('- sign tx (ms):', round((new Date() - start) / count))

        start = new Date()
        let wasm_sig = wasm_tx.sign(wasm_private_key, SigHash.InputsOutputs, 0, wasm_script, BigInt(0));
        for (let i = 0; i < count; i++) {
            wasm_tx.verify(wasm_public_key, wasm_sig)
        }
        log('- verify sig (ms):', round((new Date() - start) / count))

        log('')
    </script>
</html>